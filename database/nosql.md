<h2>redis</h2

<h3>redis的常用数据结构和使用场景</h3>

+ string: 存储字符串类型、整数或者浮点数
  + 一般使用场景： 1.作为热点数据的缓存， 2.计数器（自增自减运算）  
+ list: 双向列表
  + 一般使用场景： 1.作为消息队列
+ hashmap: 包含键值对的无序散列表
+ set: 无序集合
  + 一般使用场景：1.一些交集并集的场景
+ zset: 有序集合

<h3>如何保证缓存与数据库双写时的数据一致性？</h3>

+ 共有四种方案：
  + 先更新数据库，后更新缓存
  + 先更新缓存，后更新数据库
  + 先删除缓存，后更新数据库
  + 先更新数据库，后删除缓存
第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。

第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。
目前主要用第三和第四种方案。
 #### 1.先删除缓存，后更新数据库
 + 该方案存在的问题：此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）
    +  1.请求A进行写操作，删除缓存
    +  2.请求B查询发现缓存不存在
    +  3.请求B去数据库查询得到旧值
    +  4.请求B将旧值写入缓存
    +  5.请求A将新值写入数据库
 + 解决方案: 
    +  1.延时双删
        + 1.先淘汰缓存 
        + 2.再写数据库（这两步和原来一样） 
        + 3.休眠1秒，再次淘汰缓存，这么做，可以将1秒内所造成的缓存脏数据，再次删除。确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
        自行评估自己的项目的读数据业务逻辑的耗时，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。
     +  2.异步串行化
        + 我在系统内部维护n个内存队列，更新数据的时候，根据数据的唯一标识，将该操作路由之后，发送到其中一个jvm内部的内存队列中（对同一数据的请求发送到同一个队列）。读取数据的时候，如果发现数据不在缓存中，并且此时队列里有更新库存的操作，那么将重新读取数据+更新缓存的操作，根据唯一标识路由之后，也将发送到同一个jvm内部的内存队列中。然后每个队列对应一个工作线程，每个工作线程串行地拿到对应的操作，然后一条一条的执行。  
       这样的话，一个数据变更的操作，先执行删除缓存，然后再去更新数据库，但是还没完成更新的时候，如果此时一个读请求过来，读到了空的缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，排在刚才更新库的操作之后，然后同步等待缓存更新完成，再读库。
       
#### 2.先更新数据库，后删除缓存
+ 该方案存在的问题：，比如更新数据库成功了，但是在删除缓存的阶段出错了没有删除成功，那么此时再读取缓存的时候每次都是错误的数据了。
+ 解决方案：
   + 利用消息队列进行删除的补偿
     + 1.请求 A 先对数据库进行更新操作
     + 2.在对 Redis 进行删除操作的时候发现报错，删除失败
     + 3.此时将Redis 的 key 作为消息体发送到消息队列中
     + 4.系统接收到消息队列发送的消息后再次对 Redis 进行删除操作
     缺点：业务代码造成大量的侵入，深深的耦合在一起
     改进：ysql 数据库更新操作后再 binlog 日志中我们都能够找到相应的操作，那么我们可以订阅 Mysql 数据库的 binlog 日志对缓存进行操作。
     
<h3>redis并发分布式锁</h3>

redis的分布式锁实现 setnx+expire
超时解锁导致并发
例如：如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。
A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：
解决方案：1）确保代码在过期时间之前释放。2)为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。

锁被别的线程误删除。
例如：如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。
解决方案是：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。


<h3>redis的持久化</h3>

+ AOF 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件
+ RDB 某个时刻的所有数据都放到磁盘中（快照）


<h3></h3>

<hr>