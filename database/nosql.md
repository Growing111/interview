<h2>redis</h2

<h3>redis的常用数据结构和使用场景</h3>

+ string: 存储字符串类型、整数或者浮点数
  + 一般使用场景： 1.作为热点数据的缓存， 2.计数器（自增自减运算）  
+ list: 双向列表
  + 一般使用场景： 1.作为消息队列
+ hashmap: 包含键值对的无序散列表
+ set: 无序集合
  + 一般使用场景：1.一些交集并集的场景
+ zset: 有序集合



<h3>redis并发分布式锁</h3>

redis的分布式锁实现 setnx+expire
超时解锁导致并发
例如：如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。
A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：
解决方案：1）确保代码在过期时间之前释放。2)为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。

锁被别的线程误删除。
例如：如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。
解决方案是：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。


<h3>redis的持久化</h3>

+ AOF 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件
+ RDB 某个时刻的所有数据都放到磁盘中（快照）


<h3></h3>

<hr>