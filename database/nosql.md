<h2>redis</h2

<h3>redis的常用数据结构和使用场景</h3>

+ string: 存储字符串类型、整数或者浮点数
  + 一般使用场景： 1.作为热点数据的缓存， 2.计数器（自增自减运算）  
+ list: 双向列表
  + 一般使用场景： 1.作为消息队列
+ hashmap: 包含键值对的无序散列表
+ set: 无序集合
  + 一般使用场景：1.一些交集并集的场景
+ zset: 有序集合

<h3>如何保证缓存与数据库双写时的数据一致性？</h3>

+ 共有四种方案：
  + 先更新数据库，后更新缓存
  + 先更新缓存，后更新数据库
  + 先删除缓存，后更新数据库
  + 先更新数据库，后删除缓存
第一种和第二种方案，没有人使用的，因为第一种方案存在问题是：并发更新数据库场景下，会将脏数据刷到缓存。

第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。
目前主要用第三和第四种方案。
 ####1.先删除缓存，后更新数据库
 + 该方案存在的问题此时来了两个请求，请求 A（更新操作） 和请求 B（查询操作）
 
           1.请求A进行写操作，删除缓存
           2.请求B查询发现缓存不存在
           3.请求B去数据库查询得到旧值
           4.请求B将旧值写入缓存
           5.请求A将新值写入数据库

<h3>redis并发分布式锁</h3>

redis的分布式锁实现 setnx+expire
超时解锁导致并发
例如：如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。
A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：
解决方案：1）确保代码在过期时间之前释放。2)为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。

锁被别的线程误删除。
例如：如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。
解决方案是：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。


<h3>redis的持久化</h3>

+ AOF 以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)，只许追加文件但不可以改写文件
+ RDB 某个时刻的所有数据都放到磁盘中（快照）


<h3></h3>

<hr>