<h1>mysql</h1>


### 聚簇索引和非聚簇索引说明。对比

+ 聚簇索引: 将数据和索引放到一起，并按照一定的顺序组织的。 mysql的innodb是一定有主键的，主键一定是聚簇索引
+ 非聚簇索引： （也就辅助索引）叶子节点不存放数据，存放的是数据行地址。根据索引查找到数据行的位置。再根据数据行取到磁盘中的数据（后一个操作叫做回表）
对比：
   + 聚簇索引可以之间取数据，但是维护索引的成本比较高。
   + 聚簇索引范围查询比较快，存储是按照一定范围的
   + 聚簇索引适合排序的场景而非聚簇索引不适合
   + 聚簇索引主键比较大的话，辅助索引主要是存储主键的，也会相对占用空间较大
   + uuid做为主键，uuid是无序的会导致数据存储稀疏，可能会出现比全表扫描还更慢的情况
 
### mysql索引的数据结构

+ mysql默认的存储引擎是innodb。innodb的底层数据结构是 B+树。平衡多叉树。从根节点到每个叶子节点的高度差值不超过1，
而且叶子节点之间有指针相互链接。



### 事务的隔离级别

+ 读未提交： 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）
+ 读已提交： 这是大多数数据库系统的默认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓 的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结果。
+ 可重复读： 这是 MySQL 的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。
+ 串行化：  通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。   

### 脏读，不可重复读，幻读

+ 1、脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据  
+ 2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。
+ 3、幻读：系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读

### b树和b+树

+ B-Tree能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。
+ B+Tree数据都在叶子节点上，并且增加了顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。

区别：
+ B-Tree 中，所有节点都会带有指向具体记录的指针；B+Tree 中只有叶子结点会带有指向具体记录的指针。
+ B-Tree 中不同的叶子之间没有连在一起；B+Tree 中所有的叶子结点通过指针连接在一起。
+ B-Tree 中可能在非叶子结点就拿到了指向具体记录的指针，搜索效率不稳定；B+Tree 中，一定要到叶子结点中才可以获取到具体记录的指针，搜索效率稳定。

### Mysql事务日志

+ innodb 事务日志包括 redo log 和 undo log。
+ undo log 指事务开始之前，在操作任何数据之前，首先将需操作的数据备份到一个地方。redo log 指事务中操作的任何数据，将最新的数据备份到一个地方
  + redo log 不是随着事务的提交才写入的，而是在事务的执行过程中，便开始写入 redo 中。具体的落盘策略可以进行配置 。防止在发生故障的时间点，尚有脏页未写入磁盘，在重启 MySQL 服务的时候，根据 redo log 进行重做，从而达到事务的未入磁盘数据进行持久化这一特性。RedoLog 是为了实现事务的持久性而出现的产物。
  + undo log 用来回滚行记录到某个版本。事务未提交之前，Undo 保存了未提交之前的版本数据，Undo 中的数据可作为数据旧版本快照供其他并发事务进行快照读。是为了实现事务的原子性而出现的产物,在 MySQL innodb 存储引擎中用来实现多版本并发控制。
   
   
### MVCC快照

+ mysql的innodb的存储引擎，隔离级别默认是可重复读，主要会造成幻读，
通过使用MVCC快照处理，MVCC简称多版本并发控制器，通过保存数据在某个时间
的快照来实现，根据事务开始的时间不同，每个事务对应同一张表，同一时刻看到的数据可能不一样

### MVCC的实现原理

+ 对于 InnoDB ，聚簇索引记录中包含 3 个隐藏的列：
  + ROW ID：隐藏的自增 ID，如果表没有主键，InnoDB 会自动按 ROW ID 产生一个聚集索引树。
  + 事务 ID：记录最后一次修改该记录的事务 ID。
  + 回滚指针：指向这条记录的上一个版本。
+ InnoDB 每一行数据都有一个隐藏的回滚指针，用于指向该行修改前的最后一个历史版本，这个历史版本存放在 undo log 中。如果要执行更新操作，会将原记录放入 undo log 中，并通过隐藏的回滚指针指向 undo log 中的原记录。其它事务此时需要查询时，就是查询 undo log 中这行数据的最后一个历史版本。
 MVCC 最大的好处是读不加锁，读写不冲突，极大地增加了 MySQL 的并发性。通过 MVCC，保证了事务 ACID 中的 I（隔离性）特性。

### MVCC维护了一个ReadView结构，是什么结构作用？

+ readview结构中维护着三个字段， 事务列表（TRX_IDS）; 列表最小值 TRX_ID_MIN; 列表最大值 TRX_ID_MAX;
根据快照TRX_ID来判断。 TRX_ID只有在最小值和最大值直接,才能
m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。
min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
max_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。
小贴士： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。
creator_trx_id：表示生成该ReadView的事务的事务id。
小贴士： 我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。
有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
如果被访问版本的trx_id属性值大于或等于ReadView中的max_trx_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问



### MySQL中是如何实现事务隔离的?
 
+ 读未提交和串行化基本上是不需要考虑的隔离级别，前者不加锁限制，后者相当于单线程执行，效率太差。
MySQL 在可重复读级别解决了幻读问题，是通过行锁和间隙锁的组合 Next-Key 锁实现的。
锁定一个左开右闭的区间，锁定一个记录上的索引，也锁定索引直接的间隙。


### 聚簇索引与非聚簇索引

+ 在 InnoDB 里，我们日常所说的主键索引，其实就是聚簇索引(Clustered Index);索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引，即将数据存储与索引放到了一块，找到索引也就找到了数据。
+ 除主键索引之外，其他的都称之为非主键索引，非主键索引也被称为二级索引(Secondary Index)，或者叫作辅助索引。
  对于主键索引和非主键索引，使用的数据结构都是 B+Tree，
+ 区别：在于叶子结点中存储的内容不同，
  主键索引的叶子结点存储的是一行完整的数据。
  非主键索引的叶子结点存储的则是主键值。叶子结点不包含行记录的全部数据；非主键的叶子结点中，除了用来排序的key还包含一个bookmark；该书签存储了聚集索引的key。

### 回表查询

+ 当我们需要查询的时候：
如果是通过主键索引来查询数据，例如 select * from user where id=100，那么此时只需要搜索主键索引的 B+Tree 就可以找到数据。
如果是通过非主键索引来查询数据，例如 select * from user where username='javaboy'，那么此时需要先搜索 username 这一列索引的 B+Tree，搜索完成后得到主键的值，然后再去搜索主键索引的 B+Tree，就可以获取到一行完整的数据。
对于第二种查询方式而言，一共搜索了两棵 B+Tree，第一次搜索 B+Tree 拿到主键值后再去搜索主键索引的 B+Tree，这个过程就是所谓的回表。


### 覆盖索引

+ 比如 存在一个唯一索引 code  
select name from student where code like "%张%";
这种情况是走了索引查询，这就是一种覆盖索引的情况；

+ 1.覆盖索引是一种数据查询方式，不是索引类型
+ 2.在索引数据结构中，通过索引值可以直接找到要查询字段的值，而不需要通过主键值回表查询，那么就叫覆盖索引
+ 3.查询的字段被使用到的索引树全部覆盖到

### 最左匹配原则

+ 最左前缀原则就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
 =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。






<hr>