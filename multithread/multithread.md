<h1>多线程</h1>

### CyclicBarrier 和 CountDownLatch 的区别

+ CountDownLatch 简单的说就是一个线程等待，直到他所等待的其他线程都执行完成并
    且调用 countDown()方法发出通知后，当前线程才可以继续执行。
+ cyclicBarrier 是所有线程都进行等待，直到所有线程都准备好进入 await()方法之后，
    所有线程同时开始执行！
+ CountDownLatch 的计数器只能使用一次。而 CyclicBarrier 的计数器可以使用 reset()
    方法重置。所以 CyclicBarrier 能处理更为复杂的业务场景，比如如果计算发生错误，可以
    重置计数器，并让线程们重新执行一次。
+ CyclicBarrier 还提 供其他有 用的方法 ，比如 getNumberWaiting 方法 可以获得
    CyclicBarrier 阻塞的线程数量。isBroken 方法用来知道阻塞的线程是否被中断。如果被中断
    返回 true，否则返回 false。

### Semaphore

+ Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。

### 内存模型的三大特性

+ 原子性： Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的
+ 可见性：可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。
   主要有三种实现可见性的方式：
     + volatile (可以保证可见性，并不保证原子性)
     + synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。
     + final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。
+ 有序性：
   在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。
   实现有序行的方式：
   + volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前、
   + 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码


### CAS
+ 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B

### ThreadLocal

<hr>