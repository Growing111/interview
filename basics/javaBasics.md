<h1>java基础</h1>

<h2>Map集合</h2>

<h3>hashmap的底层结构，jdk1.7和1.8的区别</h3>
* hashmap底层是哈希表（数组+链表）的数据结构，数组中每个元素是一个单向链表 
，每个元素存放的是entry类型，entry(Entry包含四个属性：key, value, hash 值和用于单向链表的 next)，
为了解决hash冲突，采用拉链式，（链表结构）。

* 区别:
  + jdk8在数组长度大于64（不大于直接扩容），且链表长度大于8时，会转换成红黑树
  + 链表数据的插入，jdk7是通过头插法插入的，而jdk8是通过尾插法插入的。
  （多线程并发扩容情况下，头插法会形成死循环）
 
<h3>jdk1.8为什么链表需要转换成红黑树</h3>
+ 当链表过长，则会严重影响 HashMap 的性能，红黑树搜索时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红黑树，链表和红黑树在达到一定条件会进行转换：

<h3>hashmap为什么线程不安全的</h3>
+ 任意时刻可以有多个线程同时写入hashmap,导致数据不一致，数据会覆盖。


<h3>hashmap的put过程  jdk 1.8</h3>
+ 1.首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；
+ 2.如果数组是空的，则调用 resize 进行初始化；
+ 3.如果没有哈希冲突直接放在对应的数组下标里；
+ 4.如果冲突了，且 key 已经存在，就覆盖掉 value；
+ 5.如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；
+ 6.如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值对，若 key 存在，就覆盖掉 value。

<h3>hashmap的get过程 jdk 1.8 </h3>
+ 首先将 key hash 之后取得所定位的桶。
+ 如果桶为空则直接返回 null 。
+ 否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。
+ 如果第一个不匹配，则判断它的下一个是红黑树还是链表。
+ 红黑树就按照树的查找方式返回值。不然就按照链表的方式遍历匹配返回值。


<h3>hashmap的扩容过程</h3>
+ 扩容是调用的resize(int newCapacity)方法，
+ 扩容条件：
   + 1.hashmap默认大小是16. 负载因子是0.75.当hashmap的数组的长度达到16*0.75 =12时进行扩容，
   + 2.存放新值的时候当前存放数据发生hash碰撞(当前key计算的hash值换算出来的数组下标位置已经存在值)
+ 扩容使用一个容量更大的数组来代替已有的容量小的数组,容量为原来的2倍，扩容后，元素要不在原数组index上，要不在index+old_cap。
根据 e.hash & (newCap - 1)来计算出新数组的位置。

<h3>hashmap的优势</h3>
+ 在于hashmap底层使用的是哈希表（数组+链表）的数据结构，对于查询，插入和删除效率都高

<h3>解决hash冲突有哪些方法</h3>
+ 解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。HashMap中采用的是 链地址法 。
+ 开放定址法也称为再散列法，基本思想就是，如果p=H(key)出现冲突时，则以p为基础，再次hash，p1=H(p),如果p1再次出现冲突，则以p1为基础，以此类推，直到找到一个不冲突的哈希地址pi。 因此开放定址法所需要的hash表的长度要大于等于所需要存放的元素，而且因为存在再次hash，所以只能在删除的节点上做标记，而不能真正删除节点。
+ 再哈希法(双重散列，多重散列)，提供多个不同的hash函数，当R1=H1(key1)发生冲突时，再计算R2=H2(key1)，直到没有冲突为止。 这样做虽然不易产生堆集，但增加了计算的时间。
+ 链地址法(拉链法)，将哈希值相同的元素构成一个同义词的单链表,并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。
建立公共溢出区，将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。

<h3>ConcurrentHashMap底层原理，为啥是线程安全的，jdk1.7和1.8的区别</h5>
+ jdk1.7中ConcurrentHashMap 是  一个Segment数组,Segment 通过继承ReentrantLock 来进行加锁，（segment是一个内部类型，HashMap 非常类似，唯一的区别就是其中的核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性。）
每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全
+ jdk1.8中舍弃了segment概念，采用了cas和sychronized保证并发安全性。

<h3>ConcurrentHashMap的put()过程</h3>
+ jdk 1.7
  + 1.将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。
  + 2.遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。
  + 3.不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。
  + 4.最后会解除在 1 中所获取当前 Segment 的锁。
+ jdk 1.8
  + 1.根据 key 计算出 hashcode 。
  + 2.判断是否需要进行初始化。
  + 3.当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。
  + 4.如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。
  + 5.如果都不满足，则利用 synchronized 锁写入数据。
  + 6.如果数量大于 TREEIFY_THRESHOLD(8) 则要转换为红黑树

<h3>ConcurrentHashMap的get()过程</h3>
+ 1.根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。
+ 2.如果是红黑树那就按照树的方式获取值。
+ 3.都不满足那就按照链表的方式遍历获取

<hr>

   