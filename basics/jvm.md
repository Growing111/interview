<h1>jvm</h1>

### jvm的运行时内存模型

![jvm核心模块](src/main/resources/img-storage/jvm01.png)

+ 程序计数器： 存储当前线程所执行的字节码的行号指示器，用于cpu时间片轮换，记录之前运行到哪一步了
+ 方法区：用于保存已被虚拟机加载的类信息(类的版本，字段，方法，接口和父类信息)，运行时常量信息（static，final修饰的常量和字符串常量信息）  
+ 本地方法栈：存放调用的native方法
+ 虚拟机栈：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；
+ 堆：创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域
+ 线程私有的虚拟机栈，本地方法栈和程序计数器，线程共享的有方法区和堆。

### 类加载过程

![类加载过程](src/main/resources/img-storage/class load.png)

  将class文件放至内存中，通过对数据进行校验，转换，解析和初始化，形成可以被虚拟机使用的class类对象
+ 装载：
   +  通过类的完全限定名称获取定义该类的二进制字节流。
   +  将该字节流表示的静态存储结构转换为方法区的运行时存储结构。
   +  在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口
+ 链接
  + 验证：验证Class文件格式
  + 准备：为静态变量(static修改)分配内存并设置默认的初始值
  + 解析：将符合引用转换为直接引用
+ 初始化：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句（将类的静态变量赋予我们自己设置的初始化值）

### 类加载器

![双亲委派过程](src/main/resources/img-storage/sqwp.png)
JVM的类加载的过程是通过引导类加载器（bootstrap classloader）创建一个初始类（initial class）来完成
+ 双亲委派模型
  + 1.在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。
  + 2.加载的时候，首先会把该请求委派给该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。
  + 3.当父类加载器无法处理时，才由自己来处理。
+ 类加载器（自顶向下）
  + bootstrap类加载器，加载/lib/rt.jar下的jar包
  + extension类加载器，加载/lib/*.jar下的jar包
  + application类加载器，加载classpath下的jar包 默认项目代码都会被打包到classpath下通过该类加载器加载。
作用：使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。


### 判断一个对象是否可被回收

+ 引用计数法 给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收； 缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；
+ 可达性分析 从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，
  在java中可以作为GC Roots的对象有以下几种：
   + 虚拟机栈中引用的对象
   + 方法区类静态属性引用的变量
   + 方法区常量池引用的对象
   + 本地方法栈JNI引用的对象

### 强引用、软引用、弱引用、虚引用是什么，有什么区别？

+ 强引用: 就是普通的对象引用关系，如 String s = new String("123")  没有任何正常引用后会被GC回收
```js
Object obj = new Object();
```
+ 软引用: 用于维护一些可有可无的对象。共用一块缓存，缓存不够用，新增后覆盖前面的，当在内存不足时，系统则会回收软引用对象;
```
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
obj = null; // 使对象只被软引用关联
```
+ 弱引用: 被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。
  ThreadLocal实现使用
```
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
obj = null;
```
+ 虚引用: 为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。 ZeroCopy,NIO实现使用
```
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj, null);
obj = null
```

### 垃圾回收算法

+ 标记清除
  + 第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记； 
  + 第二步：在遍历一遍，将所有标记的对象回收掉； 
  特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；
+ 标记整理
  + 第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记； 
  + 第二步：将所有的存活的对象向一段移动，将端边界以外的对象都回收掉； 
  特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；
+ 复制算法
  + 将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除； 
  特点：不会产生空间碎片；内存使用率极低；
+ 分代算法
  + 根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，
  只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收；

对比: 
![垃圾回收对比](src/main/resources/img-storage/ljhssf.png)

### 垃圾回收器

+ 垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1
+ Serial:单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，是client级别的默认GC方式。
+ ParNew:Serial收集器的多线程版本，也需要stop the world，复制算
+ Parallel Scavenge:新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量；
+ Serial Old:Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
+ Parallel Old：是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
+ CMS:是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片； 
+ G1:标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率

![垃圾回收器](src/main/resources/img-storage/ljhssf.png)

### CMS垃圾回收过程

CMS是基于“标记-清除”算法实现的。CMS 回收过程分为以下四步：
+ 1.初始标记 （CMS initial mark)：主要是标记 GC Root 开始的下级（注：仅下一级）对象，这个过程会 STW，但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。
+ 2.并发标记 (CMS concurrent mark)：根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。这个过程是多线程的，虽然耗时理论上会比较长，但是其它工作线程并不会阻塞，没有 STW。
+ 3.重新标记（CMS remark）：顾名思义，就是要再标记一次。为啥还要再标记一次？因为第 2 步并没有阻塞其它工作线程，其它线程在标识过程中，很有可能会产生新的垃圾。
+ 4.并发清除（CMS concurrent sweep）：清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的。

### CMS存在的问题

##### 1. 并发回收导致CPU资源紧张：
> 在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：（CPU核数 + 3）/ 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。

##### 2. 无法清理浮动垃圾：
> 在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。

##### 3. 并发失败（Concurrent Mode Failure）：
> 由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX**:** CMSInitiatingOccupancyFraction 参数来设置。
这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。

##### 4.内存碎片问题：
> CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。
为了解决这个问题，CMS收集器提供了一个 -XX**:+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX:**CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。

### G1垃圾回收过程
说明：G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于 标记-整理 算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制 算法实现的.

G1 回收器的运作过程大致可分为四个步骤：
+ 1.初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。
+ 2.并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。
+  3.最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。
+  4.清理阶段（会STW）：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。


### 三色标记算法
作用:
> 为了让JVM不发生或仅短时间发生 STW(Stop The World)，从而达到清除 JVM 内存垃圾的目的

三色标记法将对象的颜色分为了黑、灰、白，三种颜色。
+ 黑色:该对象已经被标记过了，且该对象下的属性也全部都被标记过了。(程序所需要的对象);
+ 灰色:对象已经被垃圾收集器扫描过了，但是对象中还存在没有扫描的引用(GC 需要从此对 象中去寻找垃圾);
+ 白色:表示对象没有被垃圾收集器访问过，即表示不可达

算法标记的过程: 
+ 1.首先创建三个集合：白、灰、黑。
+ 2.将所有对象放入白色集合中。
+ 3.然后从根节点开始遍历所有对象（注意这里并不递归遍历），把遍历到的对象从白色集合放入灰色集合。
+ 4.之后遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合
+ 5.重复 4 直到灰色中无任何对象
+ 6.通过write-barrier检测对象有变化，重复以上操作
+ 7.收集所有白色对象（垃圾）

存在对象漏标的问题:
> 并发标记的过程中，一个业务线程将一个未被扫描过的白色对象断开引用成为垃圾（删除引用），同时黑色对象引用了该对象（增加引用）（这两部可以不分先后顺序）；因为黑色对象的含义为其属性都已经被标记过了，重新标记也不会从黑色对象中去找，导致该对象被程序所需要，却又要被GC回收，此问题会导致系统出现问题，而CMS与G1，两种回收器在使用三色标记法时，都采取了一些措施来应对这些问题，CMS对增加引用环节进行处理（Increment Update），G1则对删除引用环节进行处理(SATB)。

G1 使用了 SATB 方法解决,具体流程:
+ 1.在一个灰色对象正在被一个GC线程回收时，当它已经被标记过的属性指向了一个白色对象（垃圾）
+ 2.而这个对象的属性对象本身还未全部标记结束，则为灰色不变
+ 3.而这个GC线程在标记完最后一个属性后，认为已经将所有的属性标记结束了，将这个灰色对象标记为黑色，被重新引用的白色对象，无法被标记

### 内存分配与回收策略

+ Minor GC：回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
+ Full GC：回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多

### 内存分配策略
#### 1. 对象优先在 Eden 分配
大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

#### 2. 大对象直接进入老年代

+ 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。
经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。
-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

#### 3. 长期存活的对象进入老年代

+ 为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。
-XX:MaxTenuringThreshold 用来定义年龄的阈值。

#### 4. 动态对象年龄判定
+ 虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

#### 5. 空间分配担保
在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。
如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

### Full GC 的触发条件
对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：
#### 1. 调用 System.gc()

+ 只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。

#### 2. 老年代空间不足
+ 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。
为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。

#### 3. 空间分配担保失败

+ 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。

#### 4. JDK 1.7 及以前的永久代空间不足

+ 在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。
为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。

#### 5. Concurrent Mode Failure

+ 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC

### jvm调优命令

### 1
### 
### 

<hr>