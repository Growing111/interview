<h2>jvm</h2>

<h3>jvm的运行时内存模型</h3>
+ 程序计数器： 存储当前线程所执行的字节码的行号指示器，用于cpu时间片轮换，记录之前运行到哪一步了
+ 方法区：用于保存已被虚拟机加载的类信息(类的版本，字段，方法，接口和父类信息)，运行时常量信息（static，final修饰的常量和字符串常量信息）  
+ 本地方法栈：存放调用的native方法
+ 虚拟机栈：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息；
+ 堆：创建的对象和数组都保存在 Java 堆内存中，也是垃圾收集器进行垃圾收集的最重要的内存区域
+ 线程私有的虚拟机栈，本地方法栈和程序计数器，线程共享的有方法区和堆。

<h3>类加载过程</h3>
  将class文件放至内存中，通过对数据进行校验，转换，解析和初始化，形成可以被虚拟机使用的class类对象
+ 装载：将class文件中的信息读取到内存中
+ 链接
  + 验证：验证文件格式
  + 准备：为静态变量分配内存并设置默认的初始值
  + 解析：将符合引用转换为直接引用
+ 初始化：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句（将类的静态变量赋予我们自己设置的初始化值）

<h3>类加载器</h3>
JVM的类加载的过程是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成
+ 双亲委派模型
  + 1.在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。
  + 2.加载的时候，首先会把该请求委派给该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。
  + 3.当父类加载器无法处理时，才由自己来处理。
+ 类加载器（自顶向下）
  + bootstrap类加载器，加载/lib/rt.jar下的jar包
  + extension类加载器，加载/lib/*.jar下的jar包
  + app类型加载器，加载classpath下的jar包

<h3></h3>

<hr>